java，

spring：启动流程(链接：https://www.jianshu.com/p/280c7e720d0c)
1.首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境；
2.其次，在web.xml中会提供有contextLoaderListener。在web容器启动时，会触发容器初始化事件，此时 contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用，在这个方法中，spring会初始 化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，这是一个接口类，确切的说，其实际的实现类是 XmlWebApplicationContext。这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的 context-param标签指定。在这个IoC容器初始化完毕后，spring以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；
3.再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这里是DispatcherServlet，这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请 求。DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文，用以持有spring mvc相关的bean。在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文。有了这个 parent上下文之后，再初始化自己持有的上下文。这个DispatcherServlet初始化自己上下文的工作在其initStrategies方 法中可以看到，大概的工作就是初始化处理器映射、视图解析等。这个servlet自己持有的上下文默认实现类也是 XmlWebApplicationContext。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为 Key，而是通过一些转换，具体可自行查看源码)的属性为属性Key，也将其存到ServletContext中，以便后续使用。这样每个servlet 就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些 bean。
springboot启动流程(链接：https://blog.csdn.net/chengbinbbs/article/details/88557162)
1.第一步是进行SpringApplication的初始化,配置一些基本的环境变量、资源、构造器、监听器，核心就是initialize方法里的逻辑，判断当前应用的环境是否web环境，再根据spring.factories找应用程序的初始化器和事件监听器；
2.第二步实现了应用具体的启动方案,执行run方法,主要就是计时、启动监听、配置应用环境、打印banner图形、创建并配置spring容器这些；
3.第二步中的refreshContext做了加载spring.factories、实例化bean等核心工作，是实现mybatis、redis等starter自动化配置的关键；主要是通过EnableAutoConfiguration注解关联的EnableAutoConfigurationImportSelector类中的selectImports()，来调用SpringFactoriesLoader.loadFactoryNames()获取到所有spring.factories文件中的类全限定名后再反射加载。

springcloud:
是一系列框架的有序集合,本质上是一个简单易懂,易维护,易部署的分布式系统开发工具包。
进行SpringBoot风格的再封装屏蔽调复杂的配置和实现原理,简化了如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等分布式系统基础设施的开发。




redis,

kafka,

netty,

算法，

jvm,

设计模式，

sql优化，

es：将磁盘里的东西尽量搬进内存，减少磁盘随机读取次数(同时也利用磁盘顺序读特性)，结合各种奇技淫巧的压缩算法，用及其苛刻的态度使用内存。

mongodb：

微服务与springcloud，

nacos,

dubbo,

consul,

feign,

hadoop,

docker.


业务驱动技术，设计源于生活。四年Java开发，致力于加深业务认知、提高职业素养。
熟练使用Java语言、Spring家族Web开发组件、Redis、Kafka；
掌握数据结构与算法基础、JVM内存模型、设计模式、Sql优化、ES、MongoDB；
了解微服务与Nacos、Dubbo、Consul、Feign等分布式应用开发工具、Hadoop、Docker容器化部署。

物联数据告警治理
需求：
某电厂安装大量传感器设备监测温度、湿度等与厂区环境及设备安全相关的监管指标，信息均上报Kafka，现需治理物联数据，对超标情况予以分类分级，并推送告警至监管客户端。
设计：
1.告警规则配置：针对不同设备、不同类别的数据，配置报警上下限阈值、报警等级等告警规则。
2.物联数据治理：定义易扩展、插拔式的抽象化数据源，桥接模式绑定处理器对数据进行分类、告警规则校验；持久化存储(postgres)以便图表可视化展示，并调用API推送告警。
3.可视化：提供设备、区域、监管指标、时间段等多维度的数值变化趋势图，统计局部设备到厂区总体安全健康度示图。
难点与思路：
1.700个传感器设备的数据每5秒上报一次，假定消息数临界值为1000条/秒，Kafka的吞吐量绰绰有余，但持久化及API调用耗时不定且较长，如何确保消息不堆积、提高消费速度呢？->同步处理消息分类、告警规则校验，多个线程池分别异步处理持久化、调API告警；持久化时利用循环屏障cyclicBarrier实现批量插入，告警线程池的任务队列使用优先级队列PriorityBlockingQueue；自定义拒绝策略继承DiscardOledestPolicy丢弃最老的任务，并打印堆栈、抛出异常消息至客户端。
2.需保留1年的物联数据做可视化展示，700*365*24*60*60/5=44亿条数据，如何在单机环境下存储并提升查询效率呢？->表设计：常规数据与告警数据分表；设备维度水平分表；数据行分12个字段记录60秒的值，并记录起止时间戳、平均值，以起始时间为主键索引。


社区数据汇聚网关
需求：
因治安管理要求，需将各小区信息管理平台中的人员、房屋、门禁出入、人像抓拍等信息与公安内部系统同步，汇聚社区数据、夯实管理基础。
设计：
1.数据模型与映射规则：定义数据模型，数据是双向流动要建立双向的映射规则；小区模型小而多、公安模型大而少，因此会有组合映射的情况。
2.数据同步流程：定时或动作启动触发器，然后触发器主动或被动获取源数据后通过解析器把源映射为目的数据，最后发送至目的地；其中触发及发送涉及Http调用，需考虑可能的请求认证、请求异常与资源的使用问题。
3.数据流动展示：以公安系统为中心，展示与各小区平台间数据交互量的统计图，体现各类数据的成功同步量、失败详细记录。
难点与思路：
1.数据模型繁多、映射关系复杂，手写映射代码不可取，映射工具如何选型？->Orika基于javassist生成映射的字节码加载执行，可灵活映射各种字段，并且支持自定义转换器可在映射过程中添加操作，但不支持组合映射需做额外工作；MapStruct在编译时生成get/set代码，性能最优并支持组合映射，并且支持扩展实现更符合开闭原则，就是规则较多时会导致类膨胀；综上最后选用了MapStruct完成映射工作。
2.涉及到Http请求，可能出现的需认证、网络堵塞、请求异常等问题该如何解决并提高容错率？->使用okhttp3，设定重试机制并创建连接池，避免重复握手与创建销毁http连接的消耗，提高利用率；编码上加入中间层对请求进行预处理和后处理，预处理添加认证，后处理记录异常请求；架构上加入中间层kafka，数据同步任务先入队，避免高峰流量过大冲垮连接池。


停车场云平台
需求：
为小区、医院等停车场客户提供一站式的解决方案，支持多支付通道以及人工、二维码、无感等多方式缴费。
设计与实现：
1.微服务模块划分：设备接入、租户管控、车库管理、缴费统计、支付通道，我负责对接各个支付系统支撑缴费流程。
2.插拔式易扩展：抽象化支付通道，使用OpenFeign模板化接口，只需注册至注册中心并实现抽象即可完成新通道的接入。
3.快速支付流程：基于ZooKeeper的分布式队列提供高性能高可用的消息通知服务，主被动并行查询/接收支付结果,实现支付到开道闸的低延时。


天然气站点安消一张图
需求：
某省天然气各管理站点采购了视频监控、消防报警设备与软件管理平台，各区域责任人希望通过一张图直观看到站点内实时的安防消防状况。
设计：
根据一张图原型提供相应后台接口，websocket推送实时的状况，不同责任人管理范围不同，需通过用户权限配置实现一人一图的展示。
难点与思路：
各站点共有100个左右的责任人，如何提高websocket的连接数，并降低延时？->netty实现websocket，NIO实现更高并发通信。


walle开发脚手架
需求：
建立统一规范的开发脚手架，标准化开发、半自动化编码，减少重复工作量，提高代码扩展性及可维护性。
负责事项：
1.基于统一身份认证CAS实现的单点登录SSO。
2.自定义API注解，反射解析生成符合规范的API文档。
3.动态连接数据源并读取表、字段信息，提供页面展示和代码生成功能，基于freemaker模板引擎和表字段信息生成前后端代码。


数据报表平台
需求：
基于行内数据库，提供通过编写sql脚本，生成自定义报表的功能，需支持筛选、分页、隐藏列、多级表头。
设计：
1.sql管理：以sql为中心的数据源管理，使用Druid SQL解析器解析sql并管理查询字段、结果字段信息。
2.报表展示：sql脚本可发布为报表展示页面，支持条件分页查询、列隐藏与导出。
难点与思路：
1.如何正确美观的展示多级表头以及列隐藏带来的表头多重变化？->bootstrap-table表格插件功能完备，不过V1.12.1有缺陷，多表头时使用列隐藏会导致串位，更改源码修复了缺陷。


产品管理平台
需求：
构建银行金融产品的定义与运营平台，以标准化产品组件和个性化产品参数应对特异化的产品需求。
负责事项：
1.产品查询模块的开发，使用redis提供高性能的查询服务。
2.搭建Jenkins环境，支撑自动化打包部署。